/**
 * This file is part of Niowire.
 *
 * Niowire is free software: you can redistribute it and/or modify it under the
 * terms of the Lesser GNU General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * Niowire is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the Lesser GNU General Public License for more
 * details.
 *
 * You should have received a copy of the Lesser GNU General Public License
 * along with Niowire. If not, see <http://www.gnu.org/licenses/>.
 */
package io.niowire.server;

import io.niowire.data.NioPacket;
import io.niowire.entities.NioObjectCreationException;
import io.niowire.entities.NioObjectFactory;
import io.niowire.inspection.NioInspector;
import io.niowire.serializer.NioSerializer;
import io.niowire.server.NioConnection.Context;
import io.niowire.serversource.NioServerDefinition;
import io.niowire.service.NioService;
import java.io.IOException;
import java.net.InetAddress;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;

import static io.niowire.testutilities.CreateCommonMocks.*;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

/**
 * Unit tests for the {@link NioSocketServer}
 *
 * @author Trent Houliston
 */
public class NioSocketServerTest
{

	private static final Deserialize DESERIALIZE = new Deserialize();

	/**
	 * Tests that the server writes data generated by the server back to the
	 * client
	 *
	 * @throws Exception
	 */
	@Test(timeout = 1000)
	public void testReadWriteClientClose() throws Exception
	{
		//<editor-fold defaultstate="collapsed" desc="Setup Server and Mocking">
		//Create our server
		NioSocketServer server = new NioSocketServer();

		//Create our definition
		NioServerDefinition def;
		int serverPort;

		//Create a captor so we can verify our data
		ArgumentCaptor<NioPacket> packetCaptor;
		ArgumentCaptor<Context> contextCaptor;

		NioSerializer serializer = mock(NioSerializer.class);
		NioInspector inspector = mock(NioInspector.class);
		NioService service = mock(NioService.class);

		NioObjectFactory<NioSerializer> serializerFactory = mockNioObjectFactory(serializer);
		NioObjectFactory<NioInspector> inspectorFactory = mockNioObjectFactory(inspector);
		NioObjectFactory<NioService> serviceFactory = mockNioObjectFactory(service);

		//Mock our data flow
		when(serializer.deserialize(any(ByteBuffer.class))).then(DESERIALIZE);
		when(serializer.read(any(ByteBuffer.class))).then(new Answer<Integer>()
		{
			@Override
			public Integer answer(InvocationOnMock invocation) throws Throwable
			{
				ByteBuffer buff = (ByteBuffer) invocation.getArguments()[0];

				buff.put("Sending you back some data".getBytes("utf-8"));

				return "Sending you back some data".getBytes("utf-8").length;
			}
		});
		when(inspector.inspect(any(NioPacket.class))).then(new ReturnParametersAnswer<NioPacket>());

		//Build our first definition
		def = new NioServerDefinition();
		def.setId(DEFAULT_SERVER_ID);
		def.setName(DEFAULT_SERVER_NAME);
		def.setPort(null);
		def.setSerializerFactory(serializerFactory);
		def.setInspectorFactory(inspectorFactory);
		def.setServiceFactories(Collections.singletonList(serviceFactory));

		//Create a thread to run the socket server in and start it
		Thread t = new Thread(server);
		t.setDaemon(true);
		t.start();

		//Add the server
		serverPort = server.addServer(def);

		//</editor-fold>

		//<editor-fold defaultstate="collapsed" desc="Test Reading from client">
		//Connect to the server and send a message (test read)
		Socket con = new Socket(InetAddress.getLoopbackAddress(), serverPort);
		con.getOutputStream().write("Hello World!!".getBytes("utf-8"));

		packetCaptor = ArgumentCaptor.forClass(NioPacket.class);

		//Wait for the methods to run
		verify(serializer, timeout(100)).deserialize(any(ByteBuffer.class));
		verify(inspector, timeout(100)).inspect(any(NioPacket.class));
		verify(service, timeout(100)).send(packetCaptor.capture());

		//Check that the packet came through
		assertEquals("The packet that was received was invalid", DEFAULT_SERVER_NAME, packetCaptor.getValue().getSource());
		assertEquals("The packet that was received was invalid", "Hello World!!", packetCaptor.getValue().getData());
		//</editor-fold>

		//<editor-fold defaultstate="collapsed" desc="Test Writing to client">
		//Get our context (curtosy of the service object)
		contextCaptor = ArgumentCaptor.forClass(Context.class);
		verify(service).setContext(contextCaptor.capture());
		Context context = contextCaptor.getValue();

		//Return true for us having data
		when(serializer.hasData()).thenReturn(true);

		//Pretend to write some data (doesn't need to be data as the data is read back through Read)
		context.write(null);

		//Read back from the socket and check it's what's expected
		byte[] bytes = new byte["Sending you back some data".getBytes("utf-8").length];
		con.getInputStream().read(bytes);
		assertArrayEquals(bytes, "Sending you back some data".getBytes("utf-8"));
		//</editor-fold>

		//<editor-fold defaultstate="collapsed" desc="Test client closing connection">
		con.close();

		//Check that the serializer closes (implying the connection closes)
		verify(serializer, timeout(100)).close();

		//Shutdown the server
		server.shutdown();
		//</editor-fold>
	}

	/**
	 * This test tests modifying the servers in the SocketServer. It ensures
	 * that the following actions are taken.
	 *
	 * Firstly that when a server is added, that the connection comes up as
	 * expected.
	 *
	 * Secondly that when a server is "Safely" (no port change) updated that the
	 * meta data changes in it's active connections
	 *
	 * Thirdly that when a server is "Unsafely" (port change) updated, that the
	 * existing connections are maintained (on the old port) and their meta data
	 * is updated. That the socket server for this old port is closed, and that
	 * a new socket server for this server is updated.
	 *
	 * Finally that when the server is removed, that all connections (from this
	 * port or previous ports) are removed, And that the socket is no longer
	 * open.
	 *
	 * @throws Exception
	 */
	@Test(timeout = 1000)
	public void testModifyingServers() throws Exception
	{
		//<editor-fold defaultstate="collapsed" desc="Setup Server and Mocking">
		//Create our server
		NioSocketServer server = new NioSocketServer();

		//Create our definition
		NioServerDefinition[] defs = new NioServerDefinition[3];
		Socket[] sockets = new Socket[6];
		int[] serverPorts = new int[6];

		//Create a captor so we can verify our data
		ArgumentCaptor<NioPacket> packetCaptor1;
		ArgumentCaptor<NioPacket> packetCaptor2;

		//Mock the serializers for the servers (converts the passed buffer into a string)
		NioSerializer[] serializers = new NioSerializer[3];

		serializers[0] = mock(NioSerializer.class);
		when(serializers[0].deserialize(any(ByteBuffer.class))).then(DESERIALIZE);
		serializers[1] = mock(NioSerializer.class);
		when(serializers[1].deserialize(any(ByteBuffer.class))).then(DESERIALIZE);
		serializers[2] = mock(NioSerializer.class);
		when(serializers[2].deserialize(any(ByteBuffer.class))).then(DESERIALIZE);

		//Mock our inspectors (simply returns the packets it was given)
		NioInspector[] inspectors = new NioInspector[3];
		inspectors[0] = mock(NioInspector.class);
		when(inspectors[0].getUid()).thenReturn("server0");
		when(inspectors[0].inspect(any(NioPacket.class))).then(new ReturnParametersAnswer<NioPacket>());
		inspectors[1] = mock(NioInspector.class);
		when(inspectors[1].getUid()).thenReturn("server1");
		when(inspectors[1].inspect(any(NioPacket.class))).then(new ReturnParametersAnswer<NioPacket>());
		inspectors[2] = mock(NioInspector.class);
		when(inspectors[2].getUid()).thenReturn("server2");
		when(inspectors[2].inspect(any(NioPacket.class))).then(new ReturnParametersAnswer<NioPacket>());

		//Mock two services for each server (for updating with and validating the data got to the correct spot)
		NioService[][] services = new NioService[3][2];
		services[0][0] = mock(NioService.class);
		services[0][1] = mock(NioService.class);
		services[1][0] = mock(NioService.class);
		services[1][1] = mock(NioService.class);
		services[2][0] = mock(NioService.class);
		services[2][1] = mock(NioService.class);

		//Mock our factories
		@SuppressWarnings("unchecked")
		NioObjectFactory<NioSerializer>[] serializerFactories = (NioObjectFactory<NioSerializer>[]) new NioObjectFactory<?>[3];
		serializerFactories[0] = mockNioObjectFactory(serializers[0]);
		serializerFactories[1] = mockNioObjectFactory(serializers[1]);
		serializerFactories[2] = mockNioObjectFactory(serializers[2]);
		@SuppressWarnings("unchecked")
		NioObjectFactory<NioInspector>[] inspectorFactories = (NioObjectFactory<NioInspector>[]) new NioObjectFactory<?>[3];
		inspectorFactories[0] = mockNioObjectFactory(inspectors[0]);
		inspectorFactories[1] = mockNioObjectFactory(inspectors[1]);
		inspectorFactories[2] = mockNioObjectFactory(inspectors[2]);

		//Mock our service factories
		@SuppressWarnings("unchecked")
		NioObjectFactory<NioService>[][] serviceFactories = (NioObjectFactory<NioService>[][]) new NioObjectFactory<?>[3][2];
		serviceFactories[0][0] = mockNioObjectFactory(services[0][0]);
		serviceFactories[0][1] = mockNioObjectFactory(services[0][1]);
		serviceFactories[1][0] = mockNioObjectFactory(services[1][0]);
		serviceFactories[1][1] = mockNioObjectFactory(services[1][1]);
		serviceFactories[2][0] = mockNioObjectFactory(services[2][0]);
		serviceFactories[2][1] = mockNioObjectFactory(services[2][1]);

		//Build our first definition
		defs[0] = new NioServerDefinition();
		defs[0].setId("DEF_0");
		defs[0].setName("Definition0");
		defs[0].setPort(null);
		defs[0].setSerializerFactory(serializerFactories[0]);
		defs[0].setInspectorFactory(inspectorFactories[0]);
		defs[0].setServiceFactories(Collections.singletonList(serviceFactories[0][0]));

		//Build our second definition
		defs[1] = new NioServerDefinition();
		defs[1].setId("DEF_1");
		defs[1].setName("Definition1");
		defs[1].setPort(null);
		defs[1].setSerializerFactory(serializerFactories[1]);
		defs[1].setInspectorFactory(inspectorFactories[1]);
		defs[1].setServiceFactories(Collections.singletonList(serviceFactories[1][0]));

		//Build our third definition
		defs[2] = new NioServerDefinition();
		defs[2].setId("DEF_2");
		defs[2].setName("Definition2");
		defs[2].setPort(null);
		defs[2].setSerializerFactory(serializerFactories[2]);
		defs[2].setInspectorFactory(inspectorFactories[2]);
		defs[2].setServiceFactories(Collections.singletonList(serviceFactories[2][0]));

		//Create a thread to run the socket server in and start it
		Thread t = new Thread(server);
		t.setDaemon(true);
		t.start();

		//Add the three servers
		serverPorts[0] = server.addServer(defs[0]);
		serverPorts[1] = server.addServer(defs[1]);
		serverPorts[2] = server.addServer(defs[2]);
		//</editor-fold>

		//<editor-fold defaultstate="collapsed" desc="Initial Write Check">
		//Connect three sockets to the connection
		sockets[0] = new Socket(InetAddress.getLoopbackAddress(), serverPorts[0]);
		sockets[1] = new Socket(InetAddress.getLoopbackAddress(), serverPorts[1]);
		sockets[2] = new Socket(InetAddress.getLoopbackAddress(), serverPorts[2]);

		//Check that all three sockets connected
		assertTrue("Socket 0 did not connect", sockets[0].isConnected());
		assertTrue("Socket 1 did not connect", sockets[1].isConnected());
		assertTrue("Socket 2 did not connect", sockets[2].isConnected());

		//Write some data through each of these sockets and check to make sure that it was received
		sockets[0].getOutputStream().write("Def 1 Write 1".getBytes("utf-8"));
		sockets[0].getOutputStream().flush();

		//Capture the final packet sent to the service
		packetCaptor1 = ArgumentCaptor.forClass(NioPacket.class);

		//Wait for the methods to run
		verify(serializers[0], timeout(100)).deserialize(any(ByteBuffer.class));
		verify(inspectors[0], timeout(100)).inspect(any(NioPacket.class));
		verify(services[0][0], timeout(100)).send(packetCaptor1.capture());

		//Check the right packet was recieved
		assertEquals("The packets were not equal", "Def 1 Write 1", packetCaptor1.getValue().getData());
		assertEquals("The packets were not equal", DEFAULT_SERVER_NAME, packetCaptor1.getValue().getSource());

		sockets[1].getOutputStream().write("Def 2 Write 1".getBytes("utf-8"));
		sockets[1].getOutputStream().flush();

		//Capture the final packet sent to the service
		packetCaptor1 = ArgumentCaptor.forClass(NioPacket.class);

		//Wait for the methods to run
		verify(serializers[1], timeout(100)).deserialize(any(ByteBuffer.class));
		verify(inspectors[1], timeout(100)).inspect(any(NioPacket.class));
		verify(services[1][0], timeout(100)).send(packetCaptor1.capture());

		//Check the right packet was recieved
		assertEquals("The packets were not equal", "Def 2 Write 1", packetCaptor1.getValue().getData());
		assertEquals("The packets were not equal", DEFAULT_SERVER_NAME, packetCaptor1.getValue().getSource());

		//Write to our second socket
		sockets[2].getOutputStream().write("Def 3 Write 1".getBytes("utf-8"));
		sockets[2].getOutputStream().flush();

		//Capture the final packet sent to the service
		packetCaptor1 = ArgumentCaptor.forClass(NioPacket.class);

		//Wait for the methods to run
		verify(serializers[2], timeout(100)).deserialize(any(ByteBuffer.class));
		verify(inspectors[2], timeout(100)).inspect(any(NioPacket.class));
		verify(services[2][0], timeout(100)).send(packetCaptor1.capture());

		//Check the right packet was recieved
		assertEquals("The packets were not equal", "Def 3 Write 1", packetCaptor1.getValue().getData());
		assertEquals("The packets were not equal", DEFAULT_SERVER_NAME, packetCaptor1.getValue().getSource());
		//</editor-fold>

		//<editor-fold defaultstate="collapsed" desc="Update Server and Write Check">
		//Do three "Safe" updates to the servers (change the name and swap the service factories)
		defs[0].setName("Def0");
		defs[0].setServiceFactories(Collections.singletonList(serviceFactories[0][1]));
		defs[1].setName("Def2");
		defs[1].setServiceFactories(Collections.singletonList(serviceFactories[1][1]));
		defs[2].setName("Def3");
		defs[2].setServiceFactories(Collections.singletonList(serviceFactories[2][1]));

		server.updateServer(defs[0]);
		server.updateServer(defs[1]);
		server.updateServer(defs[2]);

		//Wait for the servers to update
		verify(services[0][1], timeout(100)).setContext(any(NioConnection.Context.class));
		verify(services[1][1], timeout(100)).setContext(any(NioConnection.Context.class));
		verify(services[2][1], timeout(100)).setContext(any(NioConnection.Context.class));

		//Check that the connections are still active
		assertFalse("Connection 1 has died", sockets[0].isClosed());
		assertFalse("Connection 2 has died", sockets[1].isClosed());
		assertFalse("Connection 3 has died", sockets[2].isClosed());

		//Write to them again and make sure that the data now goes to service 2 (and not service 1)
		sockets[0].getOutputStream().write("Def 1 Write 2".getBytes("utf-8"));
		sockets[0].getOutputStream().flush();

		//Capture the final packet sent to the service
		packetCaptor1 = ArgumentCaptor.forClass(NioPacket.class);

		//Wait for the methods to run
		verify(serializers[0], timeout(100).times(2)).deserialize(any(ByteBuffer.class));
		verify(inspectors[0], timeout(100).times(2)).inspect(any(NioPacket.class));
		verify(services[0][1], timeout(100).times(1)).send(packetCaptor1.capture());

		//Check the right packet was recieved
		assertEquals("The packets were not equal", "Def 1 Write 2", packetCaptor1.getValue().getData());
		assertEquals("The packets were not equal", DEFAULT_SERVER_NAME, packetCaptor1.getValue().getSource());

		sockets[1].getOutputStream().write("Def 2 Write 2".getBytes("utf-8"));
		sockets[1].getOutputStream().flush();

		//Capture the final packet sent to the service
		packetCaptor1 = ArgumentCaptor.forClass(NioPacket.class);

		//Wait for the methods to run
		verify(serializers[1], timeout(100).times(2)).deserialize(any(ByteBuffer.class));
		verify(inspectors[1], timeout(100).times(2)).inspect(any(NioPacket.class));
		verify(services[1][1], timeout(100).times(1)).send(packetCaptor1.capture());

		//Check the right packet was recieved
		assertEquals("The packets were not equal", "Def 2 Write 2", packetCaptor1.getValue().getData());
		assertEquals("The packets were not equal", DEFAULT_SERVER_NAME, packetCaptor1.getValue().getSource());

		//Write to our second socket
		sockets[2].getOutputStream().write("Def 3 Write 2".getBytes("utf-8"));
		sockets[2].getOutputStream().flush();

		//Capture the final packet sent to the service
		packetCaptor1 = ArgumentCaptor.forClass(NioPacket.class);

		//Wait for the methods to run
		verify(serializers[2], timeout(100).times(2)).deserialize(any(ByteBuffer.class));
		verify(inspectors[2], timeout(100).times(2)).inspect(any(NioPacket.class));
		verify(services[2][1], timeout(100).times(1)).send(packetCaptor1.capture());

		//Check the right packet was recieved
		assertEquals("The packets were not equal", "Def 3 Write 2", packetCaptor1.getValue().getData());
		assertEquals("The packets were not equal", DEFAULT_SERVER_NAME, packetCaptor1.getValue().getSource());

		//Verify that the first service did not have a packet written to it (still only the initial run)
		verify(services[0][0], times(1)).send(any(NioPacket.class));
		verify(services[1][0], times(1)).send(any(NioPacket.class));
		verify(services[2][0], times(1)).send(any(NioPacket.class));
		//</editor-fold>

		// <editor-fold defaultstate="collapsed" desc="Update Server Port and Write Check">
		//Do three "Unsafe" updates to the servers (change the ports and activate both services)

		//We can set the port to 0 (this registers as a change in port but is still an arbritrary port)
		defs[0].setName("Def0");
		defs[0].setPort(0);
		defs[0].setServiceFactories(Arrays.asList(serviceFactories[0]));
		defs[1].setName("Def2");
		defs[1].setPort(0);
		defs[1].setServiceFactories(Arrays.asList(serviceFactories[1]));
		defs[2].setName("Def3");
		defs[2].setPort(0);
		defs[2].setServiceFactories(Arrays.asList(serviceFactories[2]));

		serverPorts[3] = server.updateServer(defs[0]);
		serverPorts[4] = server.updateServer(defs[1]);
		serverPorts[5] = server.updateServer(defs[2]);

		//Wait for the servers to update
		verify(services[0][0], timeout(100).times(2)).setContext(any(NioConnection.Context.class));
		verify(services[1][0], timeout(100).times(2)).setContext(any(NioConnection.Context.class));
		verify(services[2][0], timeout(100).times(2)).setContext(any(NioConnection.Context.class));

		//Attempt to connect the socket to the old ports (should fail)
		try
		{
			new Socket(InetAddress.getLoopbackAddress(), serverPorts[0]).isConnected();
			fail("The old ports should now be closed");
		}
		catch (IOException ex)
		{
		}
		try
		{
			new Socket(InetAddress.getLoopbackAddress(), serverPorts[1]).isConnected();
			fail("The old ports should now be closed");
		}
		catch (IOException ex)
		{
		}
		try
		{
			new Socket(InetAddress.getLoopbackAddress(), serverPorts[2]).isConnected();
			fail("The old ports should now be closed");
		}
		catch (IOException ex)
		{
		}
		//Check that the existing connections are still active
		assertFalse("Connection 1 has died", sockets[0].isClosed());
		assertFalse("Connection 2 has died", sockets[1].isClosed());
		assertFalse("Connection 3 has died", sockets[2].isClosed());

		//Make 3 new connections to the server
		sockets[3] = new Socket(InetAddress.getLoopbackAddress(), serverPorts[3]);
		sockets[4] = new Socket(InetAddress.getLoopbackAddress(), serverPorts[4]);
		sockets[5] = new Socket(InetAddress.getLoopbackAddress(), serverPorts[5]);

		//Make sure they connected
		assertTrue("The new ports did not connect properly", sockets[3].isConnected());
		assertTrue("The new ports did not connect properly", sockets[4].isConnected());
		assertTrue("The new ports did not connect properly", sockets[5].isConnected());

		//Write to them again and make sure that the data goes through (to both services this time)
		sockets[0].getOutputStream().write("Def 1 Write 3".getBytes("utf-8"));
		sockets[0].getOutputStream().flush();

		//Capture the final packet sent to the service
		packetCaptor1 = ArgumentCaptor.forClass(NioPacket.class);
		packetCaptor2 = ArgumentCaptor.forClass(NioPacket.class);

		//Wait for the methods to run
		verify(serializers[0], timeout(100).times(3)).deserialize(any(ByteBuffer.class));
		verify(inspectors[0], timeout(100).times(3)).inspect(any(NioPacket.class));
		verify(services[0][0], timeout(100).times(2)).send(packetCaptor1.capture());
		verify(services[0][1], timeout(100).times(2)).send(packetCaptor2.capture());

		//Check the right packet was recieved
		assertEquals("The packets were not equal", "Def 1 Write 3", packetCaptor1.getValue().getData());
		assertEquals("The packets were not equal", DEFAULT_SERVER_NAME, packetCaptor1.getValue().getSource());
		assertEquals("The packets were not equal", "Def 1 Write 3", packetCaptor2.getValue().getData());
		assertEquals("The packets were not equal", DEFAULT_SERVER_NAME, packetCaptor2.getValue().getSource());

		sockets[1].getOutputStream().write("Def 2 Write 3".getBytes("utf-8"));
		sockets[1].getOutputStream().flush();

		//Capture the final packet sent to the service
		packetCaptor1 = ArgumentCaptor.forClass(NioPacket.class);
		packetCaptor2 = ArgumentCaptor.forClass(NioPacket.class);

		//Wait for the methods to run
		verify(serializers[1], timeout(100).times(3)).deserialize(any(ByteBuffer.class));
		verify(inspectors[1], timeout(100).times(3)).inspect(any(NioPacket.class));
		verify(services[1][0], timeout(100).times(2)).send(packetCaptor1.capture());
		verify(services[1][1], timeout(100).times(2)).send(packetCaptor2.capture());

		//Check the right packets were recieved
		assertEquals("The packets were not equal", "Def 2 Write 3", packetCaptor1.getValue().getData());
		assertEquals("The packets were not equal", DEFAULT_SERVER_NAME, packetCaptor1.getValue().getSource());
		assertEquals("The packets were not equal", "Def 2 Write 3", packetCaptor2.getValue().getData());
		assertEquals("The packets were not equal", DEFAULT_SERVER_NAME, packetCaptor2.getValue().getSource());

		//Write to our second socket
		sockets[2].getOutputStream().write("Def 3 Write 3".getBytes("utf-8"));
		sockets[2].getOutputStream().flush();

		//Capture the final packet sent to the service
		packetCaptor1 = ArgumentCaptor.forClass(NioPacket.class);
		packetCaptor2 = ArgumentCaptor.forClass(NioPacket.class);

		//Wait for the methods to run
		verify(serializers[2], timeout(100).times(3)).deserialize(any(ByteBuffer.class));
		verify(inspectors[2], timeout(100).times(3)).inspect(any(NioPacket.class));
		verify(services[2][0], timeout(100).times(2)).send(packetCaptor1.capture());
		verify(services[2][1], timeout(100).times(2)).send(packetCaptor2.capture());

		//Check the right packets were recieved
		assertEquals("The packets were not equal", "Def 3 Write 3", packetCaptor1.getValue().getData());
		assertEquals("The packets were not equal", DEFAULT_SERVER_NAME, packetCaptor1.getValue().getSource());
		assertEquals("The packets were not equal", "Def 3 Write 3", packetCaptor2.getValue().getData());
		assertEquals("The packets were not equal", DEFAULT_SERVER_NAME, packetCaptor2.getValue().getSource());

		//Write to our second socket
		sockets[3].getOutputStream().write("Def 1 Write 4".getBytes("utf-8"));
		sockets[3].getOutputStream().flush();

		//Capture the final packet sent to the service
		packetCaptor1 = ArgumentCaptor.forClass(NioPacket.class);
		packetCaptor2 = ArgumentCaptor.forClass(NioPacket.class);

		//Wait for the methods to run
		verify(serializers[0], timeout(100).times(4)).deserialize(any(ByteBuffer.class));
		verify(inspectors[0], timeout(100).times(4)).inspect(any(NioPacket.class));
		verify(services[0][0], timeout(100).times(3)).send(packetCaptor1.capture());
		verify(services[0][1], timeout(100).times(3)).send(packetCaptor2.capture());

		//Check the right packet was recieved
		assertEquals("The packets were not equal", "Def 1 Write 4", packetCaptor1.getValue().getData());
		assertEquals("The packets were not equal", DEFAULT_SERVER_NAME, packetCaptor1.getValue().getSource());
		assertEquals("The packets were not equal", "Def 1 Write 4", packetCaptor2.getValue().getData());
		assertEquals("The packets were not equal", DEFAULT_SERVER_NAME, packetCaptor2.getValue().getSource());

		//Write to our second socket
		sockets[4].getOutputStream().write("Def 2 Write 4".getBytes("utf-8"));
		sockets[4].getOutputStream().flush();

		//Capture the final packet sent to the service
		packetCaptor1 = ArgumentCaptor.forClass(NioPacket.class);
		packetCaptor2 = ArgumentCaptor.forClass(NioPacket.class);

		//Wait for the methods to run
		verify(serializers[1], timeout(100).times(4)).deserialize(any(ByteBuffer.class));
		verify(inspectors[1], timeout(100).times(4)).inspect(any(NioPacket.class));
		verify(services[1][0], timeout(100).times(3)).send(packetCaptor1.capture());
		verify(services[1][1], timeout(100).times(3)).send(packetCaptor2.capture());

		//Check the right packet was recieved
		assertEquals("The packets were not equal", "Def 2 Write 4", packetCaptor1.getValue().getData());
		assertEquals("The packets were not equal", DEFAULT_SERVER_NAME, packetCaptor1.getValue().getSource());
		assertEquals("The packets were not equal", "Def 2 Write 4", packetCaptor2.getValue().getData());
		assertEquals("The packets were not equal", DEFAULT_SERVER_NAME, packetCaptor2.getValue().getSource());

		//Write to our second socket
		sockets[5].getOutputStream().write("Def 3 Write 4".getBytes("utf-8"));
		sockets[5].getOutputStream().flush();

		//Capture the final packet sent to the service
		packetCaptor1 = ArgumentCaptor.forClass(NioPacket.class);
		packetCaptor2 = ArgumentCaptor.forClass(NioPacket.class);

		//Wait for the methods to run
		verify(serializers[2], timeout(100).times(4)).deserialize(any(ByteBuffer.class));
		verify(inspectors[2], timeout(100).times(4)).inspect(any(NioPacket.class));
		verify(services[2][0], timeout(100).times(3)).send(packetCaptor1.capture());
		verify(services[2][1], timeout(100).times(3)).send(packetCaptor2.capture());

		//Check the right packet was recieved
		assertEquals("The packets were not equal", "Def 3 Write 4", packetCaptor1.getValue().getData());
		assertEquals("The packets were not equal", DEFAULT_SERVER_NAME, packetCaptor1.getValue().getSource());
		assertEquals("The packets were not equal", "Def 3 Write 4", packetCaptor2.getValue().getData());
		assertEquals("The packets were not equal", DEFAULT_SERVER_NAME, packetCaptor2.getValue().getSource());
		//</editor-fold>

		//<editor-fold defaultstate="collapsed" desc="Remove Servers and connection Closed Check">
		//Remove the servers
		server.removeServer(defs[0]);
		server.removeServer(defs[1]);
		server.removeServer(defs[2]);

		//Check that all of the connections have been closed (if their streams return end of stream)
		assertEquals("The socket should have closed", -1, sockets[0].getInputStream().read());
		assertEquals("The socket should have closed", -1, sockets[1].getInputStream().read());
		assertEquals("The socket should have closed", -1, sockets[2].getInputStream().read());
		assertEquals("The socket should have closed", -1, sockets[3].getInputStream().read());
		assertEquals("The socket should have closed", -1, sockets[4].getInputStream().read());
		assertEquals("The socket should have closed", -1, sockets[5].getInputStream().read());

		//Shutdown the server
		server.shutdown();
		//</editor-fold>
	}

	/**
	 * Test what happens when an exception occurs while accepting a new
	 * connection (we don't want to crash)
	 *
	 * @throws Exception
	 */
	@Test(timeout = 1000)
	@SuppressWarnings("unchecked")
	public void testExceptionDuringConnectionCreation() throws Exception
	{
		//<editor-fold defaultstate="collapsed" desc="Setup Server and Mocking">
		//Create our server
		NioSocketServer server = new NioSocketServer();

		//Create our definition
		NioServerDefinition def;
		int serverPort;

		//Mock a factory which throws exceptions
		NioObjectFactory<?> factory = mock(NioObjectFactory.class);
		when(factory.create()).thenThrow(NioObjectCreationException.class);

		//Build our first definition
		def = new NioServerDefinition();
		def.setId(DEFAULT_SERVER_ID);
		def.setName(DEFAULT_SERVER_NAME);
		def.setPort(null);
		def.setSerializerFactory((NioObjectFactory<NioSerializer>) factory);
		def.setInspectorFactory((NioObjectFactory<NioInspector>) factory);
		def.setServiceFactories(Collections.singletonList((NioObjectFactory<NioService>) factory));

		//Create a thread to run the socket server in and start it
		Thread t = new Thread(server);
		t.setDaemon(true);
		t.start();

		serverPort = server.addServer(def);
		//</editor-fold>

		//<editor-fold defaultstate="collapsed" desc="Test Connecting to bad server">
		Socket con = new Socket(InetAddress.getLoopbackAddress(), serverPort);

		//Wait for the factory to try to create the object
		verify(factory, timeout(100)).create();

		//Make sure the connection was closed (no longer being interaced with server side)
		assertEquals("The connection should have been immediately closed", -1, con.getInputStream().read());

		//Shutdown the server
		server.shutdown();
		//</editor-fold>
	}

	/**
	 * Test what happens when an exception occurs while reading data into the
	 * connection (we don't want to crash)
	 *
	 * @throws Exception
	 */
	@Test(timeout = 1000)
	public void testExceptionDuringDataReceive() throws Exception
	{
		//<editor-fold defaultstate="collapsed" desc="Setup Server and Mocking">
		//Create our server
		NioSocketServer server = new NioSocketServer();

		//Create our definition
		NioServerDefinition def;
		int serverPort;

		//Create a captor so we can verify our data
		ArgumentCaptor<NioPacket> packetCaptor;
		ArgumentCaptor<Context> contextCaptor;

		NioSerializer serializer = mock(NioSerializer.class);
		NioInspector inspector = mock(NioInspector.class);
		NioService service = mock(NioService.class);

		NioObjectFactory<NioSerializer> serializerFactory = mockNioObjectFactory(serializer);
		NioObjectFactory<NioInspector> inspectorFactory = mockNioObjectFactory(inspector);
		NioObjectFactory<NioService> serviceFactory = mockNioObjectFactory(service);

		//Mock our data flow
		when(serializer.deserialize(any(ByteBuffer.class))).thenThrow(new IOException());

		//Build our first definition
		def = new NioServerDefinition();
		def.setId(DEFAULT_SERVER_ID);
		def.setName(DEFAULT_SERVER_NAME);
		def.setPort(null);
		def.setSerializerFactory(serializerFactory);
		def.setInspectorFactory(inspectorFactory);
		def.setServiceFactories(Collections.singletonList(serviceFactory));

		//Create a thread to run the socket server in and start it
		Thread t = new Thread(server);
		t.setDaemon(true);
		t.start();

		//Add the server
		serverPort = server.addServer(def);
		//</editor-fold>

		//<editor-fold defaultstate="collapsed" desc="Test Reading causing exception">
		//Connect to the server and send a message (test read)
		Socket con = new Socket(InetAddress.getLoopbackAddress(), serverPort);
		con.getOutputStream().write("Hello World!!".getBytes("utf-8"));

		//Wait for the methods to run
		verify(serializer, timeout(100)).deserialize(any(ByteBuffer.class));

		assertTrue("The thread should still be alive", t.isAlive());
		//</editor-fold>
	}

	/**
	 * Tests that when the connection is told to shutdown, that it shuts itself
	 * down. And closes all connections to it
	 *
	 * @throws Exception
	 */
	@Test(timeout = 1000)
	public void testShutdown() throws Exception
	{
		//<editor-fold defaultstate="collapsed" desc="Setup Server and Mocking">
		//Create our server
		NioSocketServer server = new NioSocketServer();

		//Create our definition
		NioServerDefinition def;
		int serverPort;

		NioSerializer serializer = mock(NioSerializer.class);
		NioInspector inspector = mock(NioInspector.class);
		NioService service = mock(NioService.class);

		NioObjectFactory<NioSerializer> serializerFactory = mockNioObjectFactory(serializer);
		NioObjectFactory<NioInspector> inspectorFactory = mockNioObjectFactory(inspector);
		NioObjectFactory<NioService> serviceFactory = mockNioObjectFactory(service);

		//Build our first definition
		def = new NioServerDefinition();
		def.setId(DEFAULT_SERVER_ID);
		def.setName(DEFAULT_SERVER_NAME);
		def.setPort(null);
		def.setSerializerFactory(serializerFactory);
		def.setInspectorFactory(inspectorFactory);
		def.setServiceFactories(Collections.singletonList(serviceFactory));

		//Create a thread to run the socket server in and start it
		Thread t = new Thread(server);
		t.setDaemon(true);
		t.start();
		//</editor-fold>

		//<editor-fold defaultstate="collapsed" desc="Testing server shutdown">
		//Add the server
		serverPort = server.addServer(def);

		//Connect to the server
		Socket con = new Socket(InetAddress.getLoopbackAddress(), serverPort);

		//Tell the server to shut down
		server.shutdown();

		//Wait until our connection has closed
		try
		{
			assertEquals("We should not have recieved any data", -1, con.getInputStream().read());
		}
		catch (IOException ex)
		{
			assertEquals("If an exception was thrown, only connection reset is acceptable", "Connection reset", ex.getMessage());
		}

		//Wait until the thread dies.
		t.join();
		//</editor-fold>
	}

	/**
	 * This is a helper answer class which deserializes an incoming data packet
	 * into a string using utf-8
	 */
	private static class Deserialize implements Answer<List<NioPacket>>
	{

		@Override
		public List<NioPacket> answer(InvocationOnMock invocation) throws Throwable
		{
			//Get our bytebuffer and decode it
			ByteBuffer buff = (ByteBuffer) invocation.getArguments()[0];
			CharBuffer decode = Charset.forName("utf-8").decode(buff);

			//Return a new packet with this string
			return Collections.singletonList(new NioPacket(DEFAULT_SERVER_NAME, decode.toString()));
		}
	}
}
